; 8. Return the list of nodes of a tree of type (2) accessed inorder.

; (car l) - the first element of the list is the root of the tree
; (cadr l) - the second element of the list, at superficial level, is the left subtree
; (caddr l) - the third element of the list, at the superficial level, is the right subtree


; myAppend(l1l2...ln, p1p2...pm) = 
; = p1p2...pm, if n = 0
; = {l1} U myAppend(l2...ln, p1p2...pm), otherwise


(defun myAppend (l p)
  (cond
    ((null l) p)
    (t (cons (car l) (myAppend (cdr l) p)))
  )
)

; inorder(l1l2l3) = 
; = nil, if n = 0 
; = myAppend(inorder(l2), myAppend(list(l1), inorder(l3))), otherwise


; findLevel(l1l2l3, elem, counter) = 
; = 0, if l1l2l3 is empty
; = counter, if elem = l1
; = findLevel(l2) + findLevel(l3), otherwise


(defun findLevel(l elem counter)
  (cond
    ((null l) 0)
    ((equal elem (car l)) counter)
    (t (+ (findLevel (cadr l) elem (+ 1 counter)) (findLevel (caddr l) elem (+ 1 counter))))
  )
)
